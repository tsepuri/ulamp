import traceback
import platform
from math import fabs
import json
import os
import re
from paho.mqtt.client import Client
from django.contrib.auth.models import User
from django.core.management.base import BaseCommand
from django.conf import settings
from lampi.models import *

MQTT_BROKER_PORT = 50001
MQTT_CLIENT_ID = "user_persets"

FACE_DETECTED_RE_PATTERN = r'devices\/(?P<device_id>[0-9a-z]*)\/user\/detected'
TOPIC_SET_LAMP_CONFIG = "lamp/set_config"
TOPIC_USER_DETECTED = "user/detected"

class Command(BaseCommand):
    help = 'Long-running Daemon Process to Integrate Facial recognition and preferences'

    def __init__(self, *args, **kwargs):
        super(Command, self).__init__(*args, **kwargs)
        self._updated = False
        self.hue = 1
        self.saturation = 1
        self.brightness = 1
        self.lamp_is_on = True

    def on_connect(self, client, userdata, flags, rc):
        print(f"devices/+/{TOPIC_USER_DETECTED}")
        self.mqtt.message_callback_add(f"devices/+/{TOPIC_USER_DETECTED}",
                                       self.receive_new_lamp_state)
        self.mqtt.subscribe(f"devices/+/{TOPIC_USER_DETECTED}", qos=1)

    def _create_mqtt_client_and_loop_forever(self):
        self.mqtt = Client()
        # self.mqtt.enable_logger()
        self.mqtt.on_connect = self.on_connect
        self.mqtt.connect('localhost', port=50001)
        self.mqtt.loop_forever()

    def receive_new_lamp_state(self, client, userdata, message):
        # message payload has to treated as type "bytes" in Python 3
        if message.payload != None:
            # broker connected
            print("Topic {}".format(message.topic))    
            results = re.search(FACE_DETECTED_RE_PATTERN, message.topic.lower())
            print("Parced topic {}".format(results))    
            camera_id = results.group('device_id')
            print("Camera id {}".format(camera_id))
            try:
                camera = Camera.objects.get(device_id=camera_id)
                print("Found {}".format(camera))
                print("User {}".format(camera.user))
                # Finding Associated Lampis
                lampis = Lampi.objects.filter(user=camera.user)
                for lampi in lampis:
                    new_person = json.loads(message.payload.decode('utf-8'))
                    print(new_person)
                    print(f"Device id: {lampi.device_id}")
                    preference = LampiPref.objects.get(device_id=lampi.device_id, username=new_person['name'])
                    new_state = {'color': {'h': 1, 's':1},
                        'brightness': 1,
                        'on': self.lamp_is_on,
                        'client': 'ec2'}
                    if preference != None:
                        print(f"Preferences: {preference.settings}")
                        settings = json.loads(preference.settings)
                        settings['on'] = True
                        settings['client'] = 'ec2'
                        new_state = settings

                    self._update_ui(new_state=new_state, device_id=lampi.device_id)
            
            except Exception:
                print(traceback.format_exc())

    def _update_ui(self, new_state, device_id):
        if self._updated and new_state['client'] == MQTT_CLIENT_ID:
            # ignore updates generated by this client, except the first to
            #   make sure the UI is syncrhonized with the lamp_service
            return
        try:
            if 'color' in new_state:
                self.hue = new_state['color']['h']
                self.saturation = new_state['color']['s']
            if 'brightness' in new_state:
                self.brightness = new_state['brightness']
            if 'on' in new_state:
                self.lamp_is_on = new_state['on']
            self._update_leds(device_id)
        finally:
            self._updatingUI = False

        self._updated = True

    def _update_leds(self, device_id):
        msg = {'color': {'h': self.hue, 's': self.saturation},
               'brightness': self.brightness,
               'on': self.lamp_is_on,
               'client': MQTT_CLIENT_ID}
        self.mqtt.publish(f"devices/{device_id}/{TOPIC_SET_LAMP_CONFIG}",
                          json.dumps(msg).encode('utf-8'),
                          qos=1)
    
    def handle(self, *args, **options):
        print("running")
        self._create_mqtt_client_and_loop_forever()
